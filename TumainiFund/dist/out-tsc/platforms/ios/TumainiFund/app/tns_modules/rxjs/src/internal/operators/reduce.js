import { scan } from './scan';
import { takeLast } from './takeLast';
import { defaultIfEmpty } from './defaultIfEmpty';
import { pipe } from '../util/pipe';
/* tslint:enable:max-line-length */
/**
 * Applies an accumulator function over the source Observable, and returns the
 * accumulated result when the source completes, given an optional seed value.
 *
 * <span class="informal">Combines together all values emitted on the source,
 * using an accumulator function that knows how to join a new source value into
 * the accumulation from the past.</span>
 *
 * ![](reduce.png)
 *
 * Like
 * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),
 * `reduce` applies an `accumulator` function against an accumulation and each
 * value of the source Observable (from the past) to reduce it to a single
 * value, emitted on the output Observable. Note that `reduce` will only emit
 * one value, only when the source Observable completes. It is equivalent to
 * applying operator {@link scan} followed by operator {@link last}.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * ## Example
 * Count the number of click events that happened in 5 seconds
 * ```javascript
 * import { fromEvent, interval } from 'rxjs';
 * import { reduce, takeUntil, mapTo } from 'rxjs/operators';
 *
 * const clicksInFiveSeconds = fromEvent(document, 'click').pipe(
 *   takeUntil(interval(5000)),
 * );
 * const ones = clicksInFiveSeconds.pipe(mapTo(1));
 * const seed = 0;
 * const count = ones.pipe(reduce((acc, one) => acc + one, seed));
 * count.subscribe(x => console.log(x));
 * ```
 *
 * @see {@link count}
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link scan}
 *
 * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function
 * called on each source value.
 * @param {R} [seed] The initial accumulation value.
 * @return {Observable<R>} An Observable that emits a single value that is the
 * result of accumulating the values emitted by the source Observable.
 * @method reduce
 * @owner Observable
 */
export function reduce(accumulator, seed) {
    // providing a seed of `undefined` *should* be valid and trigger
    // hasSeed! so don't use `seed !== undefined` checks!
    // For this reason, we have to check it here at the original call site
    // otherwise inside Operator/Subscriber we won't know if `undefined`
    // means they didn't provide anything or if they literally provided `undefined`
    if (arguments.length >= 2) {
        return function reduceOperatorFunctionWithSeed(source) {
            return pipe(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source);
        };
    }
    return function reduceOperatorFunction(source) {
        return pipe(scan((acc, value, index) => accumulator(acc, value, index + 1)), takeLast(1))(source);
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVkdWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGxhdGZvcm1zL2lvcy9UdW1haW5pRnVuZC9hcHAvdG5zX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvb3BlcmF0b3JzL3JlZHVjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQzlCLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDdEMsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRWxELE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFNcEMsbUNBQW1DO0FBRW5DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWtERztBQUNILE1BQU0sVUFBVSxNQUFNLENBQU8sV0FBb0QsRUFBRSxJQUFRO0lBQ3pGLGdFQUFnRTtJQUNoRSxxREFBcUQ7SUFDckQsc0VBQXNFO0lBQ3RFLG9FQUFvRTtJQUNwRSwrRUFBK0U7SUFDL0UsSUFBSSxTQUFTLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRTtRQUN6QixPQUFPLFNBQVMsOEJBQThCLENBQUMsTUFBcUI7WUFDbEUsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbEYsQ0FBQyxDQUFDO0tBQ0g7SUFDRCxPQUFPLFNBQVMsc0JBQXNCLENBQUMsTUFBcUI7UUFDMUQsT0FBTyxJQUFJLENBQ1QsSUFBSSxDQUFDLENBQUMsR0FBTSxFQUFFLEtBQVEsRUFBRSxLQUFhLEVBQUssRUFBRSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUNoRixRQUFRLENBQUMsQ0FBQyxDQUFDLENBQ1osQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNaLENBQUMsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBzY2FuIH0gZnJvbSAnLi9zY2FuJztcbmltcG9ydCB7IHRha2VMYXN0IH0gZnJvbSAnLi90YWtlTGFzdCc7XG5pbXBvcnQgeyBkZWZhdWx0SWZFbXB0eSB9IGZyb20gJy4vZGVmYXVsdElmRW1wdHknO1xuaW1wb3J0IHsgT3BlcmF0b3JGdW5jdGlvbiwgTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgcGlwZSB9IGZyb20gJy4uL3V0aWwvcGlwZSc7XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZTxUPihhY2N1bXVsYXRvcjogKGFjYzogVCwgdmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IFQsIHNlZWQ/OiBUKTogTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZTxUPihhY2N1bXVsYXRvcjogKGFjYzogVFtdLCB2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gVFtdLCBzZWVkOiBUW10pOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFRbXT47XG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlPFQsIFI+KGFjY3VtdWxhdG9yOiAoYWNjOiBSLCB2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gUiwgc2VlZD86IFIpOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFI+O1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cblxuLyoqXG4gKiBBcHBsaWVzIGFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIG92ZXIgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBhbmQgcmV0dXJucyB0aGVcbiAqIGFjY3VtdWxhdGVkIHJlc3VsdCB3aGVuIHRoZSBzb3VyY2UgY29tcGxldGVzLCBnaXZlbiBhbiBvcHRpb25hbCBzZWVkIHZhbHVlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Db21iaW5lcyB0b2dldGhlciBhbGwgdmFsdWVzIGVtaXR0ZWQgb24gdGhlIHNvdXJjZSxcbiAqIHVzaW5nIGFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIHRoYXQga25vd3MgaG93IHRvIGpvaW4gYSBuZXcgc291cmNlIHZhbHVlIGludG9cbiAqIHRoZSBhY2N1bXVsYXRpb24gZnJvbSB0aGUgcGFzdC48L3NwYW4+XG4gKlxuICogIVtdKHJlZHVjZS5wbmcpXG4gKlxuICogTGlrZVxuICogW0FycmF5LnByb3RvdHlwZS5yZWR1Y2UoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcmVkdWNlKSxcbiAqIGByZWR1Y2VgIGFwcGxpZXMgYW4gYGFjY3VtdWxhdG9yYCBmdW5jdGlvbiBhZ2FpbnN0IGFuIGFjY3VtdWxhdGlvbiBhbmQgZWFjaFxuICogdmFsdWUgb2YgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIChmcm9tIHRoZSBwYXN0KSB0byByZWR1Y2UgaXQgdG8gYSBzaW5nbGVcbiAqIHZhbHVlLCBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS4gTm90ZSB0aGF0IGByZWR1Y2VgIHdpbGwgb25seSBlbWl0XG4gKiBvbmUgdmFsdWUsIG9ubHkgd2hlbiB0aGUgc291cmNlIE9ic2VydmFibGUgY29tcGxldGVzLiBJdCBpcyBlcXVpdmFsZW50IHRvXG4gKiBhcHBseWluZyBvcGVyYXRvciB7QGxpbmsgc2Nhbn0gZm9sbG93ZWQgYnkgb3BlcmF0b3Ige0BsaW5rIGxhc3R9LlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGFwcGxpZXMgYSBzcGVjaWZpZWQgYGFjY3VtdWxhdG9yYCBmdW5jdGlvbiB0byBlYWNoXG4gKiBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiBhIGBzZWVkYCB2YWx1ZSBpcyBzcGVjaWZpZWQsIHRoZW5cbiAqIHRoYXQgdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbml0aWFsIHZhbHVlIGZvciB0aGUgYWNjdW11bGF0b3IuIElmIG5vIHNlZWRcbiAqIHZhbHVlIGlzIHNwZWNpZmllZCwgdGhlIGZpcnN0IGl0ZW0gb2YgdGhlIHNvdXJjZSBpcyB1c2VkIGFzIHRoZSBzZWVkLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2xpY2sgZXZlbnRzIHRoYXQgaGFwcGVuZWQgaW4gNSBzZWNvbmRzXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBpbXBvcnQgeyBmcm9tRXZlbnQsIGludGVydmFsIH0gZnJvbSAncnhqcyc7XG4gKiBpbXBvcnQgeyByZWR1Y2UsIHRha2VVbnRpbCwgbWFwVG8gfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG4gKlxuICogY29uc3QgY2xpY2tzSW5GaXZlU2Vjb25kcyA9IGZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJykucGlwZShcbiAqICAgdGFrZVVudGlsKGludGVydmFsKDUwMDApKSxcbiAqICk7XG4gKiBjb25zdCBvbmVzID0gY2xpY2tzSW5GaXZlU2Vjb25kcy5waXBlKG1hcFRvKDEpKTtcbiAqIGNvbnN0IHNlZWQgPSAwO1xuICogY29uc3QgY291bnQgPSBvbmVzLnBpcGUocmVkdWNlKChhY2MsIG9uZSkgPT4gYWNjICsgb25lLCBzZWVkKSk7XG4gKiBjb3VudC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBjb3VudH1cbiAqIEBzZWUge0BsaW5rIGV4cGFuZH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqIEBzZWUge0BsaW5rIHNjYW59XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbihhY2M6IFIsIHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogUn0gYWNjdW11bGF0b3IgVGhlIGFjY3VtdWxhdG9yIGZ1bmN0aW9uXG4gKiBjYWxsZWQgb24gZWFjaCBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge1J9IFtzZWVkXSBUaGUgaW5pdGlhbCBhY2N1bXVsYXRpb24gdmFsdWUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYSBzaW5nbGUgdmFsdWUgdGhhdCBpcyB0aGVcbiAqIHJlc3VsdCBvZiBhY2N1bXVsYXRpbmcgdGhlIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgcmVkdWNlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlPFQsIFI+KGFjY3VtdWxhdG9yOiAoYWNjOiBSLCB2YWx1ZTogVCwgaW5kZXg/OiBudW1iZXIpID0+IFIsIHNlZWQ/OiBSKTogT3BlcmF0b3JGdW5jdGlvbjxULCBSPiB7XG4gIC8vIHByb3ZpZGluZyBhIHNlZWQgb2YgYHVuZGVmaW5lZGAgKnNob3VsZCogYmUgdmFsaWQgYW5kIHRyaWdnZXJcbiAgLy8gaGFzU2VlZCEgc28gZG9uJ3QgdXNlIGBzZWVkICE9PSB1bmRlZmluZWRgIGNoZWNrcyFcbiAgLy8gRm9yIHRoaXMgcmVhc29uLCB3ZSBoYXZlIHRvIGNoZWNrIGl0IGhlcmUgYXQgdGhlIG9yaWdpbmFsIGNhbGwgc2l0ZVxuICAvLyBvdGhlcndpc2UgaW5zaWRlIE9wZXJhdG9yL1N1YnNjcmliZXIgd2Ugd29uJ3Qga25vdyBpZiBgdW5kZWZpbmVkYFxuICAvLyBtZWFucyB0aGV5IGRpZG4ndCBwcm92aWRlIGFueXRoaW5nIG9yIGlmIHRoZXkgbGl0ZXJhbGx5IHByb3ZpZGVkIGB1bmRlZmluZWRgXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVkdWNlT3BlcmF0b3JGdW5jdGlvbldpdGhTZWVkKHNvdXJjZTogT2JzZXJ2YWJsZTxUPik6IE9ic2VydmFibGU8Uj4ge1xuICAgICAgcmV0dXJuIHBpcGUoc2NhbihhY2N1bXVsYXRvciwgc2VlZCksIHRha2VMYXN0KDEpLCBkZWZhdWx0SWZFbXB0eShzZWVkKSkoc291cmNlKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiByZWR1Y2VPcGVyYXRvckZ1bmN0aW9uKHNvdXJjZTogT2JzZXJ2YWJsZTxUPik6IE9ic2VydmFibGU8Uj4ge1xuICAgIHJldHVybiBwaXBlKFxuICAgICAgc2NhbigoYWNjOiBSLCB2YWx1ZTogVCwgaW5kZXg6IG51bWJlcik6IFIgPT4gYWNjdW11bGF0b3IoYWNjLCB2YWx1ZSwgaW5kZXggKyAxKSksXG4gICAgICB0YWtlTGFzdCgxKSxcbiAgICApKHNvdXJjZSk7XG4gIH07XG59XG4iXX0=